import{a as p}from"./chunk-GJE7V3ZJ.js";import"./chunk-THHCAWET.js";import{a as u}from"./chunk-6FMLIRIY.js";import{Jb as y,L as r,Ma as g,Na as c,ha as l,ra as d,rb as i}from"./chunk-ZQZS5QUD.js";import{a,b as o,g as v}from"./chunk-P2VZOJAX.js";var f=v(y());var b={title:"ADRs List",mdFile:"./index.md",category:p,order:2},s=b;var m=[];var k={},h=k;var x=`<h3 id="riskphysics-adrs-list" class="ngde">RiskPhysics ADRs List<a title="Link to heading" class="ng-doc-header-link ngde" href="/architecture-documentation/architectural-decision-records/adrs-list#riskphysics-adrs-list"><ng-doc-icon icon="link-2" size="16" class="ngde"></ng-doc-icon></a></h3><table class="ngde"><thead class="ngde"><tr class="ngde"><th class="ngde">ADR</th><th class="ngde">Description</th></tr></thead><tbody class="ngde"><tr class="ngde"><td class="ngde"><a href="/architecture-documentation/architectural-decision-records/adrs-list#angular-and-micro-frontends" class="ngde">Angular and Micro Frontends</a></td><td class="ngde">Choosing UI Framework</td></tr><tr class="ngde"><td class="ngde"><a href="/architecture-documentation/architectural-decision-records/adrs-list#test-automation-framework" class="ngde">Test Automation Framework</a></td><td class="ngde">Choosing Test Automation Framework</td></tr></tbody></table><h4 id="angular-and-micro-frontends" class="ngde">Angular and Micro Frontends<a title="Link to heading" class="ng-doc-header-link ngde" href="/architecture-documentation/architectural-decision-records/adrs-list#angular-and-micro-frontends"><ng-doc-icon icon="link-2" size="16" class="ngde"></ng-doc-icon></a></h4><p class="ngde"><strong class="ngde">Title</strong>: Choosing Angular and Micro Frontends with Nx<br class="ngde"><strong class="ngde">Date</strong>: 2024-09-25<br class="ngde"><strong class="ngde">Status</strong>: Accepted</p><p class="ngde"><strong class="ngde">Context</strong>: We need a scalable and maintainable frontend architecture for our application that supports independent teams working on different parts of the system. The application requires a robust, component-driven framework with strong tooling and support for building modular applications. Additionally, we want the ability to break the application into micro frontends to enable independent deployment and scaling of different UI modules.</p><p class="ngde">We evaluated several options, including Angular, React, Vue.js, and Svelte, as well as different monorepo management tools.</p><p class="ngde"><strong class="ngde">Decision</strong>: We chose to use Angular as the primary UI framework and Nx as the tool to manage micro frontends. This decision was made based on the following factors:</p><ul class="ngde"><li class="ngde"><strong class="ngde">Component Reusability</strong>: Angular provides a strong component-driven architecture with built-in support for features like dependency injection, forms, routing, and HTTP services, reducing the need for additional libraries.</li><li class="ngde"><strong class="ngde">Enterprise-Grade Framework</strong>: Angular's comprehensive tooling and built-in TypeScript support provide the structure needed for large-scale applications, particularly when multiple teams are involved.</li><li class="ngde"><strong class="ngde">Nx for Monorepo and Micro Frontends</strong>: Nx provides a monorepo structure that simplifies the management of multiple frontends and libraries, making it easy to share code between micro frontends. Its generators, code scaffolding, and built-in testing support reduce manual overhead.</li><li class="ngde"><strong class="ngde">Separation of Concerns</strong>: With micro frontends, we can independently develop, test, and deploy different sections of the application, improving agility.</li><li class="ngde"><strong class="ngde">Team Expertise</strong>: The team has prior experience with Angular, which will speed up development and reduce learning curves.</li></ul><p class="ngde"><strong class="ngde">Consequences</strong>:</p><ul class="ngde"><li class="ngde"><p class="ngde"><strong class="ngde">Positive</strong>:</p><ul class="ngde"><li class="ngde"><strong class="ngde">Maintainability</strong>: The component-based architecture and modularity of Angular and Nx will make the application easier to maintain and scale.</li><li class="ngde"><strong class="ngde">Independent Deployment</strong>: Using micro frontends allows different teams to develop, test, and deploy UI modules independently without affecting other parts of the application.</li><li class="ngde"><strong class="ngde">Improved Developer Productivity</strong>: Nx's tooling and generators will accelerate development and reduce errors.</li><li class="ngde"><strong class="ngde">Future-Proofing</strong>: Angular's frequent updates and strong community support ensure long-term viability.</li></ul></li><li class="ngde"><p class="ngde"><strong class="ngde">Negative</strong>:</p><ul class="ngde"><li class="ngde"><strong class="ngde">Steeper Learning Curve</strong>: New team members unfamiliar with Angular and Nx may experience a learning curve.</li><li class="ngde"><strong class="ngde">Initial Setup Overhead</strong>: Setting up a micro frontend architecture adds complexity to the initial project configuration.</li></ul></li></ul><h3 id="test-automation-framework" class="ngde">Test Automation Framework<a title="Link to heading" class="ng-doc-header-link ngde" href="/architecture-documentation/architectural-decision-records/adrs-list#test-automation-framework"><ng-doc-icon icon="link-2" size="16" class="ngde"></ng-doc-icon></a></h3><p class="ngde"><strong class="ngde">Title</strong>: Selection of Test Automation Framework<br class="ngde"><strong class="ngde">Date</strong>: 2024-09-26<br class="ngde"><strong class="ngde">Status</strong>: Accepted</p><p class="ngde"><strong class="ngde">Context</strong>: We are building a large-scale application requiring robust end-to-end (E2E) testing, integration with CI/CD pipelines, cross-browser support, and fast feedback loops. Our testing framework must provide flexibility in handling authentication, API testing, and parallel test execution. Additionally, ease of setup, debugging capabilities, and community support are critical to accelerating our development workflow.</p><p class="ngde">After evaluating various tools like Selenium, Playwright, and Cypress, we considered the following requirements:</p><ul class="ngde"><li class="ngde">Support for multiple programming languages (Java, TypeScript, JavaScript)</li><li class="ngde">Cross-browser support (Chrome, Firefox, Edge, Safari)</li><li class="ngde">Parallel execution and CI/CD integration</li><li class="ngde">Fast execution times for faster feedback</li><li class="ngde">Built-in support for debugging, API testing, and cookie handling</li><li class="ngde"><strong class="ngde">Additional Tools</strong>:<ul class="ngde"><li class="ngde"><strong class="ngde">JUnit5 + Playwright with Java</strong>: Chosen as our primary testing stack to leverage Java for backend testing with a familiar toolchain.</li><li class="ngde"><strong class="ngde">Maven</strong>: For dependency management and to streamline Playwright test commands into our CI/CD pipeline.</li><li class="ngde"><strong class="ngde">Postman</strong>: For API testing to complement Playwright's E2E tests.</li><li class="ngde"><strong class="ngde">JMeter</strong>: For performance and load testing.</li></ul></li><li class="ngde"><strong class="ngde">Alternatives Considered</strong>:<ul class="ngde"><li class="ngde"><strong class="ngde">Selenium</strong>: While Selenium supports multiple languages and browsers, the WebDriver-based architecture introduces complexity in test setup and slower execution. It also requires additional tools for debugging and API testing, which could slow down our CI/CD pipeline.</li><li class="ngde"><strong class="ngde">Cypress</strong>: Cypress offers an excellent JavaScript-based testing experience, fast execution, and strong debugging features. However, it lacks comprehensive cross-browser support (limited to Chrome, Edge, and Firefox in beta) and has no mobile device testing support, making it unsuitable for our requirements.</li></ul></li></ul><p class="ngde"><strong class="ngde">Decision</strong>: We have selected <strong class="ngde">Playwright</strong> as our test automation framework for the following reasons:</p><ul class="ngde"><li class="ngde"><strong class="ngde">Language Support</strong>: Playwright supports Java, JavaScript, TypeScript, and Python, giving us flexibility in language choice.</li><li class="ngde"><strong class="ngde">Browser Support</strong>: Playwright supports Chrome, Firefox, WebKit (Safari, Edge), which fulfills our cross-browser testing requirements.</li><li class="ngde"><strong class="ngde">Execution Speed</strong>: Playwright's direct browser control makes test execution significantly faster compared to Selenium's WebDriver-based architecture.</li><li class="ngde"><strong class="ngde">Built-in Features</strong>: Playwright offers built-in handling for cookies, local storage, and automatic waits, simplifying complex testing scenarios.</li><li class="ngde"><strong class="ngde">Parallel Execution</strong>: Playwright supports out-of-the-box parallel test execution without the need for additional setup like Selenium Grid.</li><li class="ngde"><strong class="ngde">CI/CD Integration</strong>: It integrates easily with most CI/CD pipelines, aligning well with our automation goals.</li><li class="ngde"><strong class="ngde">Debugging Tools</strong>: It offers strong debugging tools, including network tracing and time-travel debugging features that simplify the development process.</li></ul><p class="ngde"><strong class="ngde">Consequences</strong>:</p><ul class="ngde"><li class="ngde"><p class="ngde"><strong class="ngde">Positive</strong>:</p><ul class="ngde"><li class="ngde">Faster test execution and reduced test flakiness due to Playwright's direct browser control and automatic waits.</li><li class="ngde">Simplified CI/CD integration and parallel test execution, speeding up our test feedback loop.</li><li class="ngde">Comprehensive debugging and network tracing tools will reduce debugging time during development.</li><li class="ngde">Built-in mobile device testing support allows us to future-proof the framework for mobile platforms.</li></ul></li><li class="ngde"><p class="ngde"><strong class="ngde">Negative</strong>:</p><ul class="ngde"><li class="ngde">Slight learning curve for team members unfamiliar with Playwright.</li></ul></li></ul><p class="ngde"><strong class="ngde">References</strong>:</p><ul class="ngde"><li class="ngde">(2024, April 11). Cypress Documentation: Comprehensive Cypress Test Automation Guide. Retrieved September 3, 2024, from <a href="https://docs.cypress.io/guides/overview/why-cypress" class="ngde">https://docs.cypress.io/guides/overview/why-cypress</a></li><li class="ngde">The Selenium Browser Automation Project. (2023, November 17). Selenium. Retrieved September 3, 2024, from <a href="https://www.selenium.dev/documentation" class="ngde">https://www.selenium.dev/documentation</a></li><li class="ngde">Installation. (n.d.). Playwright. Retrieved September 3, 2024, from <a href="https://playwright.dev/docs/intro" class="ngde">https://playwright.dev/docs/intro</a></li></ul>`,C=(()=>{let e=class e extends i{constructor(){super(),this.routePrefix="",this.pageType="guide",this.pageContent=x,this.page=s,this.demoAssets=h}};e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=r({type:e,selectors:[["ng-doc-page-architecture-documentation-architectural-decision-records-adrs-list"]],standalone:!0,features:[g([{provide:i,useExisting:e},m,s.providers??[]]),l,c],decls:1,vars:0,template:function(n,P){n&1&&d(0,"ng-doc-page")},dependencies:[u],encapsulation:2,changeDetection:0});let t=e;return t})(),A=[o(a({},(0,f.isRoute)(s.route)?s.route:{}),{path:"",component:C,title:"ADRs List"})],O=A;export{C as DynamicComponent,O as default};
